}
retvar
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
library(ggplot2)
c_list <- seq(0, 0.01, 1)[-1]
d_list <- seq(0, 0.01, 1)[-1]
whether_stable <- function(c,d) {
tr <- -c -d^2 + 2*d^2/(c+d^2) -1
det <- c + d^2
lambda1 <- as.complex((tr + sqrt(tr^2-4*det+0i))/2)
lambda2 <- as.complex((tr - sqrt(tr^2-4*det+0i))/2)
# test whether this combination of c and d is stable
if ((Re(lambda1) < 0) && (Re(lambda2) < 0)) {
return(1)
} else {
return(0)
}
}
re <- matrix(0, nrow = length(c_list)*length(d_list), ncol=3)
i <- 1
for (c in c_list) {
for (d in d_list) {
re[i, ] <- c(c, d, whether_stable(c,d))
i <- i + 1
}
}
re
re
ret <- matrix(0, nrow = length(c_list)*length(d_list), ncol=3)
i <- 1
for (c in c_list) {
for (d in d_list) {
rer[i, ] <- c(c, d, whether_stable(c,d))
i <- i + 1
}
}
return(code)
ret
ret <- matrix(0, nrow = length(c_list)*length(d_list), ncol=3)
i <- 1
for (c in c_list) {
for (d in d_list) {
rer[i, ] <- c(c, d, whether_stable(c,d))
print(c(c, d, whether_stable(c,d)))
i <- i + 1
}
}
s
u
c(c(), 1)
c( c(c(), 1), 2)
7.142857e-06*30000*2
0.4285714/(0.4285714+1)
''
\'
''
0.3*0.5/(0.15+0.7)
rep_len(100, length.out = 10)
list(`a`=2)
list(`a-b`=2)
a <- c(1,2,3)
b <- c(4,5,6)
expand.grid(a,b)
str(expand.grid(a,b))
1 == NA
library(tidyverse)
install.packages("purrr")
library(igraph)
library(tidyverse)
summarizeNetwork <- function(filePath) {
dat <- read.delim(filePath, h=T) %>%
select(c(Official.Symbol.Interactor.A, Official.Symbol.Interactor.B))
adjmatrix <- get.adjacency(graph.edgelist(as.matrix(dat), directed=FALSE))
g <- graph_from_adjacency_matrix(adjmatrix, mode="undirected")
totalInteractions <- gsize(g)
networkDensity <- graph.density(g,loop=FALSE)
averageDegree <- mean(degree(g))
highestDegree <- max(degree(g))
highestDegreeProtein <- V(g)$name[degree(g)==highestDegree]
clusteringCoef <- transitivity(g, type="localundirected")
index <- degree(g) >= 3
maxClusteringCoef <- max(clusteringCoef[index])
maxClusteringCoefProtein <-  V(g)$name[clusteringCoef == maxClusteringCoef]
return(list(
totalInteractions =  totalInteractions,
networkDensity =  networkDensity,
averageDegree = averageDegree,
highestDegreeProtein = paste0(highestDegreeProtein, "(", highestDegree, ")"),
maxClusteringCoefProtein = paste0(maxClusteringCoefProtein, "(", maxClusteringCoef, ")")
))
}
filePath <- c(
"BIOGRID-PUBLICATION-21816-3.5.178.tab2.txt",
"BIOGRID-PUBLICATION-21817-3.5.178.tab2.txt",
"BIOGRID-PUBLICATION-77339-3.5.178.tab2.txt",
"BIOGRID-PUBLICATION-85442-3.5.178.tab2.txt"
)
filePath %>%
purrr::map(summarizeNetwork)
install.packages("unikn")
library(unikn)
library(igraph)
library(tidyverse)
# calculate mutation rate
gene_mutations <- gene_mutations %>%
left_join(read.csv("gene_lengths.csv"))
# calculate mutation rate
gene_mutations <- gene_mutations %>%
left_join(read.csv("gene_lengths.csv"))
gene_mutations <- mutations %>%
group_by(Hugo_Symbol) %>%
summarize(n_totals = n())
Q<-1.3
sqrt(Q^2-6*Q+1+0i)
-0.3/2
sqrt(Q^2-6*Q+1+0i)/2
1.3*11.7
pi
pi/13.7
(pi/13.7)^2
w2 <- seq(0, 100, 0.1)
w2
pi/13.7
0.2293133^1
0.2293133^2
-15.21* 0.05258459
4*2.5
4*2.6
69.86+10.49+14.49+71.33+1162
x <- NULL
is.na(x)
is.null(x)
Inf
if(Inf == Inf)
{print(1)}
i<-1
1:i
(1-0.05)*0.3/((1-0.05)*0.3+0.7)
0.5 + 1/4 * (0.15 - 0.05)
0.15+0.05
0.5+1/4*(0.05-0.15)
mat <- matrix(
data = c(0.525, 0.05, 0.05, 0.05, -0.05, -0.05, -0.05, -0.05,
0.05, 0.525, 0.05, 0.05, -0.05, -0.05, -0.05, -0.05,
0.05, 0.05, 0.525, 0.05, -0.05, -0.05, -0.05, -0.05,
0.05, 0.05, 0.05, 0.525, -0.05, -0.05, -0.05, -0.05,
-0.05, -0.05, -0.05, -0.05, 0.475, 0.05, 0.05, 0.05,
-0.05, -0.05, -0.05, -0.05, 0.05, 0.475, 0.05, 0.05,
-0.05, -0.05, -0.05, -0.05, 0.05, 0.05, 0.475, 0.05,
-0.05, -0.05, -0.05, -0.05, 0.05, 0.05, 0.05, 0.475), nrow = 8, ncol = 8)
eigen(mat)
0.3748391/0.3309013
(1+4*0.05+3*0.15)/(1+3*0.05+4*0.15)
1/(1+4*0.05+3*0.15)/(1+3*0.05+4*0.15)
1/0.9428571
(2+4*0.05+2*0.15)/(2+2*0.05+4*0.15)
1/0.9259259
0.3309013/0.3748391
rep.int(c(1,2,3), times=c(1,2,3))
rep_len(1,1)
rep_len(1,100)
rep_len
rep_len(1,1100)
plot(x1, y)
a <- 1
b <- 0.1
c <- 1
d <- 0.005
e <- 65
l <- 120
u <- 300
t <- sample(1:100, size=n, replace=TRUE)
n <- l + u
sd <- 2.02
x1 <- a * t * (cos(b*t)) + rnorm(n=n, sd=sd)
x2 <- a * t * (sin(b*t)) + rnorm(n=n, sd=sd)
y <- c * t * exp(-d*(t-e)^2)
data <- data.frame(x1=x1, x2=x2, y=y)
scatterplot3d(data[,1:3], pch=16, color="steelblue")
a <- 1
b <- 0.1
c <- 1
d <- 0.005
e <- 65
l <- 120
u <- 300
t <- sample(1:100, size=n, replace=TRUE)
n <- l + u
sd <- 2.02
x1 <- a * t * (cos(b*t)) + rnorm(n=n, sd=sd)
x2 <- a * t * (sin(b*t)) + rnorm(n=n, sd=sd)
y <- c * t * exp(-d*(t-e)^2)
data <- data.frame(x1=x1, x2=x2, y=y)
library(scatterplot3d)
a <- 1
b <- 0.1
c <- 1
d <- 0.005
e <- 65
l <- 120
u <- 300
t <- sample(1:100, size=n, replace=TRUE)
n <- l + u
sd <- 2.02
x1 <- a * t * (cos(b*t)) + rnorm(n=n, sd=sd)
x2 <- a * t * (sin(b*t)) + rnorm(n=n, sd=sd)
y <- c * t * exp(-d*(t-e)^2)
data <- data.frame(x1=x1, x2=x2, y=y)
scatterplot3d(data[,1:3], pch=16, color="steelblue")
install.packages("GPfit")
library(scatterplot3d)
a <- 1
b <- 0.1
c <- 1
d <- 0.005
e <- 65
l <- 120
u <- 300
t <- sample(1:100, size=n, replace=TRUE)
n <- l + u
sd <- 2.02
x1 <- a * t * (cos(b*t)) + rnorm(n=n, sd=sd)
x2 <- a * t * (sin(b*t)) + rnorm(n=n, sd=sd)
y <- c * t * exp(-d*(t-e)^2)
data <- data.frame(x1=x1, x2=x2, y=y)
scatterplot3d(data[,1:3], pch=16, color="steelblue")
X <- data.frame(x1=x1, x2=x2)
Y <- y[1: 100]
idx.unmeasured <- setdiff(1:nrow(X), idx.measured)
x <- X[idx.measured, ]
y <- Y[idx.measured]
xnew <- X[idx.unmeasured, ]
GPmodel = GP_fit(x,y)
Model_pred = predict(GPmodel, xnew)
library(scatterplot3d)
library(GPfit)
a <- 1
b <- 0.1
c <- 1
d <- 0.005
e <- 65
l <- 120
u <- 300
t <- sample(1:100, size=n, replace=TRUE)
n <- l + u
sd <- 2.02
x1 <- a * t * (cos(b*t)) + rnorm(n=n, sd=sd)
x2 <- a * t * (sin(b*t)) + rnorm(n=n, sd=sd)
y <- c * t * exp(-d*(t-e)^2)
data <- data.frame(x1=x1, x2=x2, y=y)
scatterplot3d(data[,1:3], pch=16, color="steelblue")
X <- data.frame(x1=x1, x2=x2)
Y <- y[1: 100]
idx.unmeasured <- setdiff(1:nrow(X), idx.measured)
x <- X[idx.measured, ]
y <- Y[idx.measured]
xnew <- X[idx.unmeasured, ]
GPmodel = GP_fit(x,y)
Model_pred = predict(GPmodel, xnew)
library(scatterplot3d)
library(GPfit)
a <- 1
b <- 0.1
c <- 1
d <- 0.005
e <- 65
l <- 120
u <- 300
t <- sample(1:100, size=n, replace=TRUE)
n <- l + u
sd <- 2.02
x1 <- a * t * (cos(b*t)) + rnorm(n=n, sd=sd)
x2 <- a * t * (sin(b*t)) + rnorm(n=n, sd=sd)
y <- c * t * exp(-d*(t-e)^2)
data <- data.frame(x1=x1, x2=x2, y=y)
scatterplot3d(data[,1:3], pch=16, color="steelblue")
X <- data.frame(x1=x1, x2=x2)
Y <- y[1: 100]
idx.measured <- 1:100
idx.unmeasured <- setdiff(1:nrow(X), idx.measured)
x <- X[idx.measured, ]
y <- Y[idx.measured]
xnew <- X[idx.unmeasured, ]
GPmodel = GP_fit(x,y)
Model_pred = predict(GPmodel, xnew)
Model_pred$Y_hat
plot(Model_pred$Y_hat, y[101:420])
?= GP_fit
?= GP_fit
?GP_fit
GPmodel = GP_fit(x,y)
Model_pred = predict(GPmodel, xnew)
plot(Model_pred$Y_hat, y[101:420])
summary(Model_pred$Y_hat)
length(Model_pred$Y_hat)
plot(Model_pred$Y_hat)
plot(y[101:420])
plot(Y[101:420])
library(scatterplot3d)
library(GPfit)
a <- 1
b <- 0.1
c <- 1
d <- 0.005
e <- 65
l <- 120
u <- 300
t <- sample(1:100, size=n, replace=TRUE)
n <- l + u
sd <- 2.02
x1 <- a * t * (cos(b*t)) + rnorm(n=n, sd=sd)
x2 <- a * t * (sin(b*t)) + rnorm(n=n, sd=sd)
y <- c * t * exp(-d*(t-e)^2)
data <- data.frame(x1=x1, x2=x2, y=y)
scatterplot3d(data[,1:3], pch=16, color="steelblue")
X <- data.frame(x1=x1, x2=x2)
Y <- y[1: 100]
idx.measured <- 1:100
idx.unmeasured <- setdiff(1:nrow(X), idx.measured)
x <- X[idx.measured, ]
xnew <- X[idx.unmeasured, ]
GPmodel = GP_fit(x,Y)
Model_pred = predict(GPmodel, xnew)
plot(Y[101:420])
plot(y[101:420])
plot(Model_pred$Y_hat, y[101:420])
predictGP <- function(X, Y, idx.measured) {
idx.unmeasured <- setdiff(1:nrow(X), idx.measured)
x <- X[idx.measured, ]
y <- Y[idx.measured]
xnew <- X[idx.unmeasured, ]
GPmodel = GP_fit(x,y)
Model_pred = predict(GPmodel, xnew)
return(Model_pred$Y_hat)
}
predictGP(X=X, Y=Y, idx.measured = 1:100)
predictGP(X=X, Y=Y, idx.measured = 1:100)
predictGP(X=X, Y=Y, idx.measured = 1:100)
install.packages("modelr")
X
library(modelr)
folds <- crossv_kfold(X, k=5)
folds
folds$$train
folds$train
folds$train[[1]]
folds$train[[2]]
head(data)
data <- readRDS("../scripts/data/raw_data/crohnDisease/crohns_chop.RDS")
getwd()
setwd("unicorn2019/vignettes/")
data <- readRDS("../scripts/data/raw_data/crohnDisease/crohns_chop.RDS")
library(tidyverse)
data <- data %>% sample_n(10000)
library(qqman)
qq(data$pvalues)
qq(data$pvalues[data$type == "UNICORN"])
qq(data$pvalues[data$type != "UNICORN"])
setwd("~/unicorn2019/vignettes/")
data <- readRDS("../scripts/data/raw_data/crohnDisease/crohns_chop.RDS")
setwd("~/unicorn2019/vignettes/")
data <- readRDS("../scripts/data/raw_data/crohnDisease/crohns_chop.RDS")
data_unicorn <- data %>% filter(type == "UNICORN") %>% sample_n(10000)
y <- data_unicorn$pvalues
x <- runif(10000)
data <- data.frame(x=x, y=y)
ggplot(data, aes(x,y)) + geom_point()
setwd("~/unicorn2019/vignettes/")
data <- readRDS("../scripts/data/raw_data/crohnDisease/crohns_chop.RDS")
data_unicorn <- data %>% filter(type == "UNICORN") %>% sample_n(10000)
y <- data_unicorn$pvalues
x <- runif(10000)
data <- data.frame(x=x, y=y)
ggplot(data, aes(x,y)) + geom_point()
setwd("~/unicorn2019/vignettes/")
data <- readRDS("../scripts/data/raw_data/crohnDisease/crohns_chop.RDS")
data_unicorn <- data %>% filter(type == "UNICORN") %>% sample_n(10000)
y <- data_unicorn$pvalues
x <- runif(10000)
data <- data.frame(x=x, y=y)
ggplot(data, aes(x,y)) + geom_point()
library(lattice)
qqunif.plot<-function(pvalues,
should.thin=T, thin.obs.places=2, thin.exp.places=2,
xlab=expression(paste("Expected (",-log[10], " p-value)")),
ylab=expression(paste("Observed (",-log[10], " p-value)")),
draw.conf=TRUE, conf.points=1000, conf.col="lightgray", conf.alpha=.05,
already.transformed=FALSE, pch=20, aspect="iso", prepanel=prepanel.qqunif,
par.settings=list(superpose.symbol=list(pch=pch)), ...) {
#error checking
if (length(pvalues)==0) stop("pvalue vector is empty, can't draw plot")
if(!(class(pvalues)=="numeric" ||
(class(pvalues)=="list" && all(sapply(pvalues, class)=="numeric"))))
stop("pvalue vector is not numeric, can't draw plot")
if (any(is.na(unlist(pvalues)))) stop("pvalue vector contains NA values, can't draw plot")
if (already.transformed==FALSE) {
if (any(unlist(pvalues)==0)) stop("pvalue vector contains zeros, can't draw plot")
} else {
if (any(unlist(pvalues)<0)) stop("-log10 pvalue vector contains negative values, can't draw plot")
}
grp<-NULL
n<-1
exp.x<-c()
if(is.list(pvalues)) {
nn<-sapply(pvalues, length)
rs<-cumsum(nn)
re<-rs-nn+1
n<-min(nn)
if (!is.null(names(pvalues))) {
grp=factor(rep(names(pvalues), nn), levels=names(pvalues))
names(pvalues)<-NULL
} else {
grp=factor(rep(1:length(pvalues), nn))
}
pvo<-pvalues
pvalues<-numeric(sum(nn))
exp.x<-numeric(sum(nn))
for(i in 1:length(pvo)) {
if (!already.transformed) {
pvalues[rs[i]:re[i]] <- -log10(pvo[[i]])
exp.x[rs[i]:re[i]] <- -log10((rank(pvo[[i]], ties.method="first")-.5)/nn[i])
} else {
pvalues[rs[i]:re[i]] <- pvo[[i]]
exp.x[rs[i]:re[i]] <- -log10((nn[i]+1-rank(pvo[[i]], ties.method="first")-.5)/(nn[i]+1))
}
}
} else {
n <- length(pvalues)+1
if (!already.transformed) {
exp.x <- -log10((rank(pvalues, ties.method="first")-.5)/n)
pvalues <- -log10(pvalues)
} else {
exp.x <- -log10((n-rank(pvalues, ties.method="first")-.5)/n)
}
}
#this is a helper function to draw the confidence interval
panel.qqconf<-function(n, conf.points=1000, conf.col="gray", conf.alpha=.05, ...) {
require(grid)
conf.points = min(conf.points, n-1);
mpts<-matrix(nrow=conf.points*2, ncol=2)
for(i in seq(from=1, to=conf.points)) {
mpts[i,1]<- -log10((i-.5)/n)
mpts[i,2]<- -log10(qbeta(1-conf.alpha/2, i, n-i))
mpts[conf.points*2+1-i,1]<- -log10((i-.5)/n)
mpts[conf.points*2+1-i,2]<- -log10(qbeta(conf.alpha/2, i, n-i))
}
grid.polygon(x=mpts[,1],y=mpts[,2], gp=gpar(fill=conf.col, lty=0), default.units="native")
}
#reduce number of points to plot
if (should.thin==T) {
if (!is.null(grp)) {
thin <- unique(data.frame(pvalues = round(pvalues, thin.obs.places),
exp.x = round(exp.x, thin.exp.places),
grp=grp))
grp = thin$grp
} else {
thin <- unique(data.frame(pvalues = round(pvalues, thin.obs.places),
exp.x = round(exp.x, thin.exp.places)))
}
pvalues <- thin$pvalues
exp.x <- thin$exp.x
}
gc()
prepanel.qqunif= function(x,y,...) {
A = list()
A$xlim = range(x, y)*1.02
A$xlim[1]=0
A$ylim = A$xlim
return(A)
}
#draw the plot
xyplot(pvalues~exp.x, groups=grp, xlab=xlab, ylab=ylab, aspect=aspect,
prepanel=prepanel, scales=list(axs="i"), pch=pch,
panel = function(x, y, ...) {
if (draw.conf) {
panel.qqconf(n, conf.points=conf.points,
conf.col=conf.col, conf.alpha=conf.alpha)
};
panel.xyplot(x,y, ...);
panel.abline(0,1);
}, par.settings=par.settings, ...
)
}
my.pvalue.list<-list("Study 1"=runif(10000), "Study 2"=runif(10000,0,.90))
qqunif.plot(my.pvalue.list, auto.key=list(corner=c(.95,.05)))
pvals.unicorn <- data %>% filter(type == "UNICORN") %>% sample_n(50000)
pvals.gwas <- data %>% filter(type != "UNICORN") %>% sample_n(50000)
my.pvalue.list<-list("UNICORN"=pvals.unicorn, "Standard GWAS"=pvals.gwas)
qqunif.plot(my.pvalue.list, auto.key=list(corner=c(.95,.05)))
data <- readRDS("../scripts/data/raw_data/crohnDisease/crohns_chop.RDS")
pvals.unicorn <- data %>% filter(type == "UNICORN") %>% sample_n(50000)
pvals.unicorn <- pvals.unicorn$pvalues
pvals.gwas <- data %>% filter(type != "UNICORN") %>% sample_n(50000)
pvals.gwas <- pvals.gwas$pvalues
pvals.unicorn <- data %>% filter(type == "UNICORN") %>% sample_n(50000)
pvals.unicorn <- pvals.unicorn$pvalues
pvals.gwas <- data %>% filter(type != "UNICORN") %>% sample_n(50000)
pvals.gwas <- pvals.gwas$pvalues
my.pvalue.list<-list("UNICORN"=pvals.unicorn, "Standard GWAS"=pvals.gwas)
qqunif.plot(my.pvalue.list, auto.key=list(corner=c(.95,.05)))
?xyplot
qqunif.plot(my.pvalue.list, auto.key=list(corner=c(.95,.05)), xlim=c(0,5), ylim=c(0,10))
qqunif.plot(my.pvalue.list, auto.key=list(corner=c(.95,.05)), xlim=c(0,5), ylim=c(0,5))
data <- readRDS("../scripts/data/raw_data/crohnDisease/crohns_chop.RDS")
pvals.unicorn <- data %>% filter(type == "UNICORN") %>% sample_n(10000)
pvals.unicorn <- pvals.unicorn$pvalues
pvals.gwas <- data %>% filter(type != "UNICORN") %>% sample_n(10000)
pvals.gwas <- pvals.gwas$pvalues
my.pvalue.list<-list("UNICORN"=pvals.unicorn, "Standard GWAS"=pvals.gwas)
qqunif.plot(my.pvalue.list, auto.key=list(corner=c(.95,.05)), xlim=c(0,5), ylim=c(0,5))
